--[[
    https://www.scribd.com/document/758096167/Synapse-v3-Docs

    TODO
    1. Add more functions
    2. re-do all input checks
    3. re-do all return type checks (use typeof() instead of type())
]]

local HttpService = game:GetService("HttpService");
local Players = game:GetService("Players");
local ReplicatedFirst = game:GetService("ReplicatedFirst")
local RunService = game:GetService("RunService");
local StarterPlayer = game:GetService("StarterPlayer");
local UserInputService = game:GetService("UserInputService");

repeat task.wait() until Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("Head")

local Pass, NA, Fail = 0, 0, 0

local function checkFunction(aliasTable, args, callback, na)
    local mainAlias = aliasTable[1]
    local otherAliases = {table.unpack(aliasTable, 2, #aliasTable)}

    local splitFunc = mainAlias:split(".")
    local mainFunc
    if splitFunc[1] then
        mainFunc = getfenv(0)
        for i, v in pairs(splitFunc) do
            mainFunc = mainFunc and mainFunc[v]
        end
    else
        mainFunc = getfenv(0)[mainAlias]
    end

    if not mainFunc then
        Fail = Fail + 1
        warn((#otherAliases > 0 and "| 游린 - ".. mainAlias .." | function not found | Missing aliases: ".. table.concat(otherAliases, ", ") .." |" or "| 游린 - ".. mainAlias .." | function not found |"))
        return
    end

    if na then
        NA = NA + 1
        print("| 游릱 - " .. mainAlias .. " |")
        return;
    end

    local mainSuccess, mainResult = pcall(mainFunc, table.unpack(args))
    if not mainSuccess then
        Fail = Fail + 1
        local errorMsg = string.gsub(mainResult, "%S+:%d+: ", "")
        warn((#otherAliases > 0 and "| 游린 - ".. mainAlias .." | ".. errorMsg .." | missing aliases: ".. table.concat(otherAliases, ", ") .." |") or ("| 游린 - ".. mainAlias .." | ".. errorMsg .." |"))
        return
    end

    local callbackSuccess, callbackResult = pcall(callback, mainFunc, mainResult)
    if not callbackSuccess then
        Fail = Fail + 1
        local errorMsg = string.gsub(callbackResult, "%S+:%d+: ", "")
        warn((#otherAliases > 0 and "| 游린 - ".. mainAlias .." | ".. errorMsg .." | missing aliases: ".. table.concat(otherAliases, ", ") .." |") or ("| 游린 - ".. mainAlias .." | ".. errorMsg .." |"))
        return
    end

    if callbackResult == 0 then
        Pass = Pass + 1
    elseif callbackResult == 1 then
        NA = NA + 1
    else
        Fail = Fail + 1
        return
    end

    local missingAliases = {}
    for _, v in pairs(otherAliases) do
        local splitFunc = mainAlias:split(".")
        local func
        if splitFunc[1] then
            func = getfenv(0)
            for i, v in pairs(splitFunc) do
                func = func and func[v]
            end
        else
            func = getfenv(0)[mainAlias]
        end

        if not func then
            table.insert(missingAliases, v)
        else
            local success = func == mainFunc
            if not success then
                table.insert(missingAliases, v)
            end
        end
    end

    local emoji = callbackResult == 0 and "游릴" or callbackResult == 1 and "游릱" or "游린"
    local message = "| " .. emoji .. " - " .. mainAlias .. " |"
    if #missingAliases > 0 then
        message = message .. " missing aliases: " .. table.concat(missingAliases, ", ") .. " |"
    end

    if callbackResult == 0 or callbackResult == 1 then
        print(message)
    else
        warn(message)
    end
end

print("|-- Scroll Down --|"..string.rep('\n', 100))

print("")
print("|-- Environment --|")
do
    checkFunction({"getgenv"}, {0}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        test_varaible = "This is a Test!";
        assert(returned["print"], "returned table without basic lua functions");
        assert(returned["test_varaible"], "returned table without custom global variable");
        test_varaible = nil;

        return 0;
    end)

    checkFunction({"getrenv"}, {0}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(returned["print"], "returned table without basic lua functions");
        assert(returned["DockWidgetPluginGuiInfo"] and returned["CatalogSearchParams"], "returned table without default roblox global variables");
        assert(_G ~= returned["_G"], "returned table matching global tables");

        return 0;
    end)

    local thread;
    checkFunction({"getreg", "debug.getregistry"}, {0}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(#returned > 0, "returned blank table");

        assert(returned["DateTime"], "returned table without basic lua functions");
        assert(returned["DockWidgetPluginGuiInfo"] and returned["CatalogSearchParams"], "returned table without default roblox global variable");

        for i,v in pairs(returned) do
            if type(v) == "thread" then
                thread = v
                break
            end
        end
        return 0;
    end)

    checkFunction({"gettenv"}, {thread}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(thread, "failed due to not having getreg")

        assert(returned["print"], "returned table without basic lua functions");
        assert(returned["DockWidgetPluginGuiInfo"] and returned["CatalogSearchParams"], "returned table without default roblox global variables");
        assert(_VERSION == returned["_VERSION"], "returned mismatch version");

        return 0;
    end)


    local wt = setmetatable({}, { __mode = "v" })
    local test = { MNC_TEST_TABLE = true }
    wt[1] = test
    test = nil
    collectgarbage('count')
    checkFunction({"getgc"}, {true}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(#returned > 0, "returned blank table");

        local found = false
        for _, obj in ipairs(returned) do
            if type(obj) == "table" and rawget(obj, "MNC_TEST_TABLE") then
                found = true
                break
            end
        end

        assert(found, "returned table without test instance")

        return 0;
    end)

    checkFunction({"getinstances"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(#returned > 0, "returned blank table");

        assert(typeof(returned[1]) == "Instance", "returned invalid instance");

        return 0;
    end)

    checkFunction({"getnilinstances"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(#returned > 0, "returned blank table");

        assert(returned[1].parent == nil, "returned invalid instance");

        return 0;
    end)

    checkFunction({"getscripts"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(#returned > 0, "returned blank table");

        assert(typeof(returned[1]) == "Instance", "returned invalid instance");
        assert((returned[1].ClassName == "LocalScript") or (returned[1].ClassName == "ModuleScript"), "returned invalid instance");

        return 0;
    end)

    checkFunction({"getloadedmodules"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(#returned > 0, "returned blank table");

        assert(typeof(returned[1]) == "Instance", "returned invalid instance");
        assert(returned[1].ClassName == "ModuleScript", "returned invalid instance");

        return 0;
    end)

    local fired = false;
    local cd = Instance.new("ClickDetector");
    cd.MaxActivationDistance = 9e9
    cd.MouseClick:Connect(function()fired = true;end)
    checkFunction({"fireclickdetector"}, {cd, 100, "MouseClick"}, function(self, returned)
        local timeout = 0
        repeat task.wait(0.016) timeout+=0.016 until fired or timeout > 1

        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        assert(fired, "clickdetector didn't get fired")

        return 0;
    end)
    cd:Destroy();cd=nil;
    fired=nil;

    local fired = false;
    local PP = Instance.new("ProximityPrompt");
    PP.Parent = workspace
    PP.MaxActivationDistance = 9e9
    PP.Triggered:Connect(function()fired = true;end)
    checkFunction({"fireproximityprompt"}, {PP}, function(self, returned)
        local timeout = 0
        repeat task.wait(0.016) timeout+=0.016 until fired or timeout > 1

        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(fired, "proximityprompt didn't get fired")

        return 0;
    end)
    PP:Destroy();PP=nil;
    fired=nil;

    local fired = false
    local part = Instance.new("Part")
    part.Parent = workspace
    part.Touched:Connect(function()fired = true;end)
    checkFunction({"firetouchinterest"}, {game.Players.LocalPlayer.Character:WaitForChild("Head"), part, 0}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        firetouchinterest(game.Players.LocalPlayer.Character:WaitForChild("Head"), part, 1)

        task.wait(0.1)
        assert(fired, ".touched wasn't fired")

        return 0;
    end)
    part:Destroy();part=nil;
    fired=nil;
end

print("")
print("|-- Filesystem --|")
do
    local GUID = HttpService:GenerateGUID(false);
    local data = "return '"..GUID.."'";
    local hasfile = false;
    checkFunction({"writefile"}, {"MNCTest.txt", data}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")


        assert(isfile("MNCTest.txt"), "failed to create test file");
        hasfile = true;
        return 0;
    end)

    checkFunction({"loadfile"}, {"MNCTest.txt"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "function", "Expected 'function', got "..type(returned))

        if not hasfile then
            error("failed to test loadfile, test file was never created")
        end

        assert(returned() == loadstring(readfile("MNCTest.txt"))(), "not equivalent to loadstring(readfile(path))");
        return 0;
    end)

    checkFunction({"isfile"}, {"MNCTest.txt"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        if not hasfile then
            error("failed to test isfile, test file was never created")
        end

        assert(returned, "failed to validate test file");

        return 0;
    end)

    checkFunction({"readfile"}, {"MNCTest.txt"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "string", "Expected 'string', got "..type(returned))

        if not hasfile then
            error("failed to test readfile, test file was never created")
        end

        assert(returned == data, "failed to get correct text from test file");

        return 0;
    end)

    checkFunction({"appendfile"}, {"MNCTest.txt", "Test1"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        if not hasfile then
            error("failed to test appendfile, test file was never created")
        end
        assert(readfile("MNCTest.txt") == data.."Test1", "failed to get correct text from appended test file");

        return 0;
    end)

    checkFunction({"delfile"}, {"MNCTest.txt"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        if not hasfile then
            error("failed to test delfile, test file was never created")
        end

        assert(not isfile("MNCTest.txt"), "failed to delete test file");

        return 0;
    end)

    local hasfolder = false;
    checkFunction({"makefolder"}, {"MNCTest"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        assert(isfolder("MNCTest"), "failed to create test folder");
        hasfolder = true;
        return 0;
    end)

    checkFunction({"isfolder"}, {"MNCTest"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        if not hasfolder then
            error("failed to test isfolder, test folder was never created")
        end

        assert(returned, "failed to validate test folder");

        return 0;
    end)

    checkFunction({"delfolder"}, {"MNCTest"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        if not hasfolder then
            error("failed to test delfolder, test folder was never created")
        end

        assert(not isfolder("MNCTest"), "failed to delete test folder");

        return 0;
    end)

    checkFunction({"getcustomasset"}, {"test.png"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "string", "Expected 'string', got "..type(returned))

        return 1;
    end, true)

    checkFunction({"saveinstance"}, {Instance.new("Part")}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        return 0;
    end, true)

    data = nil;
    hasfile = nil;
    hasfolder = nil;
end

print("")
print("|-- Hooking --|")
do
    local function testfunction()
        return "A"
    end

    local newcTest;
    checkFunction({"newcclosure"}, {testfunction, "testcfunction"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "function", "Expected 'function', got "..type(returned))

        local returnedType = debug.info(returned, "l") == -1 and "C" or "L";

        assert(returnedType == "C", "function wasn't wrapped in a cclosure");
        assert(returned ~= testfunction, "original and C wrapped function are the same");
        assert(debug.info(returned, "n") == "testcfunction", "closures name is wrong");

        newcTest = returned

        return 0;
    end)

    checkFunction({"newlclosure"}, {newcTest or function() end, "testlfunction"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "function", "Expected 'function', got "..type(returned))

        assert(newcTest, "failed due to not having newcclosure")

        local returnedType = debug.info(returned, "l") == -1 and "C" or "L";

        assert(returnedType == "L", "function wasn't wrapped in a lclosure");
        assert(returned ~= newcTest, "original and l wrapped function are the same");
        assert(debug.info(returned, "n") == "testlfunction", "closures name is wrong");

        return 0;
    end)

    checkFunction({"iscclosure"}, {testfunction}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        assert(not returned, "returned true on a lclosure")
        assert(iscclosure(print), "returned false on a cclosure")

        return 0;
    end)

    checkFunction({"islclosure"}, {testfunction}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "boolean 'function', got "..type(returned))

        assert(returned, "returned false on a lclosure")
        assert(not islclosure(print), "returned true on a cclosure")

        return 0;
    end)

    checkFunction({"clonefunction"}, {testfunction}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "function", "Expected 'function', got "..type(returned))

        local returnedType = debug.info(returned, "l") == -1 and "C" or "L";

        assert(returnedType == "L", "cloned function was wrapped in C");
        assert(returned ~= testfunction, "original and cloned function are the same");
        return 0;
    end)

    checkFunction({"hookfunction", "replaceclosure"}, {testfunction, function() return "B" end}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "function", "Expected 'function', got "..type(returned))

        local output = returned();
        assert(output == "A", "returned function outputs different retult than original");

        local output = testfunction();
        assert(output == "B", "functions output wasn't changed");

        local returnedType = debug.info(returned, "l") == -1 and "C" or "L";
        local oreturnedType = debug.info(testfunction, "s") == "[C]" and "C" or "L";
        assert(returnedType == oreturnedType, "original and hooked functions closures are different");

        local l = function() return "l" end
        local c = clonefunction(string.upper)
        local ncc = newcclosure(function() return "ncc" end)

        do -- l -> ?
            local ltol = hookfunction(l, function() return "l2" end)
            assert(ltol() == "l", "hookfunction didn't return the original function | l -> l")
            assert(l() == "l2", "l closure wasen't hooked | l -> l")

            local ltoc = hookfunction(ltol, c)
            assert(ltoc() == "l", "hookfunction didn't return the original function | l -> c")
            assert(ltol("l") == "L", "l closure wasen't hooked | l -> c")

            local ltoncc = hookfunction(ltoc, ncc)
            assert(ltoncc() == "l", "hookfunction didn't return the original function | l -> ncc")
            assert(ltoc() == "ncc", "l closure wasen't hooked | l -> ncc")
        end

        do -- c -> ?
            local ctol = hookfunction(c, l)
            assert(ctol("c") == "C", "hookfunction didn't return the original function | c -> l")
            assert(c() == "l2", "c closure wasen't hooked | c -> l")

            local ctoc = hookfunction(ctol, c)
            assert(ctoc("l") == "L", "hookfunction didn't return the original function | c -> c")
            assert(ctol() == "l2", "c closure wasen't hooked | c -> c")

            local ctoncc = hookfunction(ctoc, ncc)
            assert(ctoncc("l") == "L", "hookfunction didn't return the original function | c -> ncc")
            assert(ctoc() == "ncc", "c closure wasen't hooked | c -> ncc")
        end

        do -- ncc -> ?
            local ncctol = hookfunction(ncc, l)
            assert(ncctol() == "ncc", "hookfunction didn't return the original function | ncc -> l")
            assert(c() == "l2", "c closure wasen't hooked | ncc -> l")

            local ncctoc = hookfunction(ncctol, c)
            assert(ncctoc() == "ncc", "hookfunction didn't return the original function | ncc -> c")
            assert(ncctol() == "l2", "c closure wasen't hooked | ncc -> c")

            local ncctoncc = hookfunction(ncctoc, ncc)
            assert(ncctoncc() == "ncc", "hookfunction didn't return the original function | ncc -> ncc")
            assert(ncctoc() == "l2", "c closure wasen't hooked | ncc -> ncc")
        end

        l = nil
        c = nil
        ncc = nil

        return 0;
    end)

    checkFunction({"restorefunction"}, {testfunction}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        local output = testfunction();
        assert(output == "A", "functions output wasn't restored");

        assert(debug.info(testfunction, "l") ~= -1, "restored function closure was elevated to c");

        return 0;
    end)

    checkFunction({"isfunctionhooked"}, {testfunction}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        hookfunction(testfunction, function() return "B" end);
        local ishooked = isfunctionhooked(testfunction);
        assert(ishooked, "returned false when function was hooked");

        restorefunction(testfunction);
        local ishooked = isfunctionhooked(testfunction);
        assert(not ishooked, "returned true when function was restored");

        return 0;
    end)

    testfunction = nil;
end

print("")
print("|-- Input --|")
do

    checkFunction({"iswindowactive", "isrbxactive"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        return 1;
    end)

    local state = false;
    checkFunction({"lockwindow"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        if iswindowlocked() then
            state = true;
        end

        assert(state, "window was not locked")
        return 0;
    end)

    checkFunction({"iswindowlocked"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        if iswindowlocked() then
            state = true;
        end

        assert(state, "window was not locked")
        return 0;
    end)

    checkFunction({"unlockwindow"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        assert(state, "window was still locked")
        return 0;
    end)
    state = nil;

    if iswindowactive then
        repeat task.wait() until iswindowactive()
    end

    local state = false
    checkFunction({"keypress"}, {0x41}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        task.wait()
        assert(UserInputService:IsKeyDown(Enum.KeyCode.A), "key was not pressed down")

        state = true
        return 0;
    end)

    checkFunction({"keyrelease"}, {0x41}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        task.wait()
        assert(state, "keypress did not press the key")
        assert(not UserInputService:IsKeyDown(Enum.KeyCode.A), "key was not released")

        return 0;
    end)
    state = nil

    local clicked = nil;
    local connection1 = UserInputService.InputBegan:Connect(function(something)
        if something.KeyCode == 0x41 then
            clicked = true;
        end
    end)

    local connection2 = UserInputService.InputEnded:Connect(function(something)
        if something.KeyCode == 0x41 then
            clicked = false;
        end
    end)

    checkFunction({"keyclick", "keytap"}, {0x41}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        local timeout = 0
        repeat task.wait(0.016) timeout+=0.016 until clicked or timeout > 1

        assert(clicked == nil, "keyclick was not fired on key")
        assert(clicked, "key was pressed but not released")

        return 0;
    end)
    connection1:Disconnect();connection1 = nil;
    connection2:Disconnect();connection2 = nil;

    checkFunction({"mouse1press"}, {0, 0}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"mouse1release"}, {0, 0}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"mouse1click"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"mouse2press"}, {0, 0}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"mouse2release"}, {0, 0}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"mouse2click"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"mousescroll"}, {0, 0}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"mousemoverel"}, {10, 10}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"mousemoveabs"}, {0, 0}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")


        return 1;
    end, true)

    checkFunction({"iskeydown"}, {0x41}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"iskeytoggled"}, {0x41}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        return 1;
    end, true)

    checkFunction({"getmousestate"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        return 1;
    end, true)

    checkFunction({"setmousestate"}, {true}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)
end

print("")
print("|-- Miscellaneous --|")
do
    checkFunction({"setclipboard"}, {"Hey!"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end)

    checkFunction({"setrbxclipboard"}, {"Hey!"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end)

    checkFunction({"setfflag"}, {"UGCValidationValidateTransparencyEnhancedErrorMessage", false}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        assert(returned, "returned false on a valid FFlag");
        return 0;
    end)

    checkFunction({"getfflag"}, {"UGCValidationValidateTransparencyEnhancedErrorMessage"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(returned == "false", "returned true when FFlag was disabled");
        setfflag("UGCValidationValidateTransparencyEnhancedErrorMessage", true)
        assert(getfflag("UGCValidationValidateTransparencyEnhancedErrorMessage"), "returned false when FFlag was enabled");

        return 0;
    end)

    checkFunction({"identifyexecutor"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "string", "Expected 'string', got "..type(returned))

        return 0;
    end)

    checkFunction({"unlockmodulescript"}, {game:GetService("StarterPlayer").StarterPlayerScripts.PlayerModule}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        return 0;
    end)

    checkFunction({"require"}, {game:GetService("StarterPlayer").StarterPlayerScripts.PlayerModule}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(returned["cameras"], "table returned without expected values")
        assert(returned["controls"], "table returned without expected values")

        return 0;
    end)

    checkFunction({"messagebox"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "number", "Expected 'number', got "..type(returned))

        return 1;
    end, true)

    checkFunction({"setwindowtitle"}, {"MNC TEST"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(getwindowtitle()=="MNC TEST", "failed to set window title")

        return 0;
    end)

    checkFunction({"getwindowtitle"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "string", "Expected 'string', got "..type(returned))

        assert(returned=="MNC TEST", "failed to set window title")
        setwindowtitle("Roblox")
        assert(getwindowtitle()=="Roblox", "failed to set window title")

        return 0;
    end)

    checkFunction({"setwindowicon"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"gethui"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "userdata", "Expected 'userdata', got "..type(returned))

        assert(returned ~= game:GetService"CoreGui", "protected container is just CoreGui")
        local a,b = pcall(function() return returned:IsDescendantOf(game:GetService"CoreGui") end)
        assert(a and not b or not a, "protected container is a descendant of CoreGui")

        return 0;
    end)

    local test = game.Workspace;
    local test2 = nil;
    checkFunction({"cloneref"}, {test}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "userdata", "Expected 'userdata', got "..type(returned))

        assert(returned ~= game:GetService"Workspace", "cloned instance is equivalent to original")
        assert(returned.CurrentCamera, "cloned workspace doesn't have CurrentCamera")
        assert(returned:FindFirstChild("Camera"), "cloned workspace doesn't have Camera child")

        test2 = returned
        return 0;
    end)

    checkFunction({"compareinstances"}, {test, test2}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        assert(test ~= test2, "cloned instance is equivalent to original")
        assert(returned, "cloned instance should've returned true")

        test, test2 = nil, nil
        return 0;
    end)

    checkFunction({"queue_on_teleport"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"clear_teleport_queue"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"setthreadidentity", "set_thread_identity"}, {2}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        assert(getthreadidentity, "test failed exploit doesn't support 'getthreadidentity'")

        assert(getthreadidentity() == 2, "thread identity wasn't set to 2")
        local a, b = pcall(function() return game.CoreGui end)
        assert(a, "thread identity 2 shouldn't be able to access CoreGui")
        setthreadidentity(7)
        return 0;
    end)

    checkFunction({"getthreadidentity", "get_thread_identity"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "number", "Expected 'number', got "..type(returned))

        assert(setthreadidentity, "test failed exploit doesn't support 'setthreadidentity'")

        assert(returned == 7, "thread identity doesn't equal 7")
        return 0;
    end)

end

print("")
print("|-- Network --|")
do
    checkFunction({"isnetworkowner"}, {game.Players.LocalPlayer.Character:FindFirstChild("Head")}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        assert(returned, "returned false on a part in your character");

        return 0;
    end)
end

print("")
print("|-- Reflection --|")
do
    checkFunction({"setscriptable"}, {Players, 'BanningEnabled', true}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))
        assert(returned, "didn't return flags original state");

        local oldbanning = Players.BanningEnabled
        pcall(function() Players.BanningEnabled = not oldbanning end)
        assert(Players.BanningEnabled == not oldbanning, "failed to set a read-only property after setting it to scriptable");
        pcall(function() Players.BanningEnabled = oldbanning end)
        oldbanning = nil

        return 0;
    end)
    old = nil

    checkFunction({"gethiddenproperty"}, {Players.LocalPlayer.Character:FindFirstChild"Humanoid", "Health_XML"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "number", "Expected 'number', got "..type(returned))


        assert(returned == Players.LocalPlayer.Character:FindFirstChild"Humanoid".Health, "returns unexpected value");
        return 0;
    end)

    checkFunction({"sethiddenproperty"}, {Players.LocalPlayer.Character:FindFirstChild"Humanoid", "Health_XML", 50}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))
        return 0;
    end)

    checkFunction({"getproperties"}, {Players.LocalPlayer.Character:FindFirstChild"Humanoid"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        local len = 0
        for i,v in pairs(returned) do
            len += 1
        end
        assert(len > 0, "returned blank table");

        assert(returned["Health"], "returned table without basic properties");
        assert(returned["Health_XML"], "returned table without non-scriptable properties");

        return 0;
    end)

    checkFunction({"gethiddenproperties"}, {Players.LocalPlayer.Character:FindFirstChild"Humanoid"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        local len = 0
        for i,v in pairs(returned) do
            len += 1
        end
        assert(len > 0, "returned blank table");

        assert(returned["Health_XML"], "returned table without non-scriptable properties");

        return 0;
    end)

    local test = RunService:BindToRenderStep("MNCTEST", 1, function()
        return;
    end)
    checkFunction({"getrendersteppedlist"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(#returned > 0, "returned blank table");

        assert(returned["MNCTEST"], "returned table without custom BindToRenderStep function");

        RunService:UnbindFromRenderStep("MNCTEST");
        test = nil;
        return 0;
    end)
end

print("")
print("|-- Script --|")
do
    checkFunction({"loadstring"}, {"return true"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "function", "Expected 'function', got "..type(returned))

        assert(returned(), "simple script returned a unexpected value");
        assert(loadstring([[
            local a = false;
            return(function(a,b)
                if b["print"] and not a then
                    return true;
                else
                    return false;
                end
            end)(a, getgenv(0))
        ]])(), "basic script returned a unexpected value");

        return 0;
    end)

    checkFunction({"checkcaller"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        assert(returned, "returned unexpected boolean");
        return 0;
    end)

    checkFunction({"isexploitfunction", "isexecutorclosure"}, {function() return true; end}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        assert(returned, "returned unexpected boolean");
        return 0;
    end)

    checkFunction({"decompile"}, {Players.LocalPlayer.PlayerScripts.PlayerScriptsLoader}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "string", "Expected 'string', got "..type(returned))

        assert(returned:find([[PlayerModule]]), "returned invalid script source | "..returned);

        return 0;
    end)

    checkFunction({"getscriptthread"}, {Players.LocalPlayer.PlayerScripts.PlayerScriptsLoader}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "userdata", "Expected 'userdata', got "..type(returned))

        return 1;
    end, true)

    checkFunction({"getsenv"}, {Players.LocalPlayer.Character:FindFirstChild("Animate")}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))


        assert(returned["onClimbing"] and returned["_G"], "returned table is missing script enviornment functions");

        return 0;
    end)

    checkFunction({"getscriptfunction", "getscriptclosure"}, {Players.LocalPlayer.Character:FindFirstChild("Animate")}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "function", "Expected 'function', got "..type(returned))

        return 0;
    end)

    --[[checkFunction({"getscripthash"}, {StarterPlayer.StarterPlayerScripts.PlayerScriptsLoader}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "string", "Expected 'string', got "..type(returned))

        assert(returned ~= getscripthash(StarterPlayer.StarterPlayerScripts.RbxCharacterSounds), "two scripts have the same hash")
        assert(returned == getscripthash(StarterPlayer.StarterPlayerScripts.PlayerScriptsLoader), "the same script has different hashes")
        return 0;
    end)]]

    local test = function() return true end;
    local test2 = function() return false end;

    checkFunction({"getfunctionhash"}, {getscriptfunction and getscriptfunction(StarterPlayer.StarterPlayerScripts.PlayerScriptsLoader) or test2}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "string", "Expected 'string', got "..type(returned))

        assert(returned ~= getfunctionhash(getscriptfunction and getscriptfunction(StarterPlayer.StarterPlayerScripts.RbxCharacterSounds) or test), "two different functions have the same hash")
        assert(returned == getfunctionhash(getscriptfunction and getscriptfunction(StarterPlayer.StarterPlayerScripts.PlayerScriptsLoader) or test2), "the same function has different hashes")

        test = nil;
        return 0;
    end)
    test = nil;
    test2 = nil;

    local test = function() return true end;
    checkFunction({"dumpbytecode"}, {test}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "string", "Expected 'string', got "..type(returned))

        assert(base64.encode(returned) == "G0x1YVEAAQQIBAgAFwAAAAAAAABALlx1bnNlY3VyZV9zYW1wbGUubHVhAAEAAAABAAAAAAAAAgMAAAACAIAAHgAAAR4AgAAAAAAAAAAAAAMAAAABAAAAAQAAAAEAAAAAAAAAAAAAAA==", "returned unexpected bytecode");

        return 0;
    end)
    test = nil;

    checkFunction({"getscriptbytecode"}, {StarterPlayer.StarterPlayerScripts.PlayerScriptsLoader}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "string", "Expected 'string', got "..type(returned))

        assert(base64.encode(returned) == "BgMFB3JlcXVpcmUGc2NyaXB0BlBhcmVudAxQbGF5ZXJNb2R1bGUMV2FpdEZvckNoaWxkAAEEAAABAgANowAAAKQAAQAAAABApAIDAAAAIEBNAQIkBAAAAG8DBQC8AQHTBgAAAJ8BAwCfAAABggABAAcDAQQAAABAAwIEAAAgQAMDAwQDBQABAAEYAAYAAAAAAAAAAAAAAQEAAAAAADSYjSSeWQX+BlznsMpuz+/Mm9vyQkuK3LLFKH84UBWGi8sNJCKyj0w=", "returned unexpected bytecode");

        return 0;
    end)

    checkFunction({"getcallingscript"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "nil", "Expected 'nil', got "..type(returned))

        local gotIt;
        local namecall; namecall = hookmetamethod(game, "__namecall", function(...)
            local args = {...}

            if not gotIt then
                gotIt = getcallingscript()
            else
                restorefunction(getrawmetatable(game).__namecall)
            end

            return namecall(...)
        end)
        local timeout = 1
        local cur = 0
        repeat task.wait(0.0016) cur = cur + 0.0016 until gotIt or cur > timeout

        assert(gotIt, "Failed to find calling script on a __namecall hook")

        return 0;
    end)
end

print("")
print("|-- Signal --|")
do
    checkFunction({"getconnections"}, {Players.LocalPlayer.Character:FindFirstChild"Humanoid".Died}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(#returned > 0, "returned blank table");

        assert(type(returned[1]) == "userdata", "returned unexpected connection")

        return 0;
    end)

    checkFunction({"firesignal"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"cfiresignal"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"replicatesignal"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        return 1;
    end, true)

    checkFunction({"cansignalreplicate"}, {Players.LocalPlayer.Character:FindFirstChild"Humanoid".AncestryChanged}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        return 0;
    end)

    checkFunction({"getsignalarguments"}, {Players.LocalPlayer.Character:FindFirstChild"Humanoid".Died}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(#returned > 0, "returned blank table");

        assert(returned[1] == "Instance" and returned[2] == "Instance", "returned unexpected table")
        return 0;
    end)

    local connectionFunction = function(deltaTime) return; end
    local test = RunService.Heartbeat:Connect(connectionFunction);
    local test2 = RunService.Heartbeat:Wait();

    checkFunction({"isconnectionenabled"}, {test}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        assert(returned, "returned false on a enabled connection")
        local suc, message = pcall(setconnectionenabled, test, false)
        if suc then
            assert(not isconnectionenabled(test), "returned true on a disabled connection")
        end
        local suc, message = pcall(setconnectionenabled, test, true)

        return 0;
    end)

    checkFunction({"setconnectionenabled"}, {test, false}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        assert(not isconnectionenabled(test), "connection wasn't disabled");
        return 0;
    end)

    checkFunction({"isluaconnection"}, {test}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        assert(returned, "returned false on a lua connection");
        return 0;
    end)

    checkFunction({"iswaitingconnection"}, {test}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        assert(not returned, "returned true on a :Connect() connection");

        assert(iswaitingconnection(test2), "returned false on a :Wait() connection");
        return 0;
    end)

    checkFunction({"getconnectionfunction"}, {test}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        --assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        assert(returned == connectionFunction, "returned incorrect test function");
        return 0;
    end)

    checkFunction({"getconnectionthread"}, {test}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "thread", "Expected 'thread', got "..type(returned))

        return 1;
    end, true)

    checkFunction({"isgamescriptconnection"}, {test}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'boolean', got "..type(returned))

        return 1;
    end)
    connectionFunction = nil;
    test:Disconnect(); test = nil;
    test2 = nil;
end

print("")
print("|-- Table --|")
do
    local testTable = {["what"] = 1, "Hello!"};
    local mt = {
        __index = function(self, index)
            return rawget(self, index);
        end,
        __newindex = function(self, index, value)
            rawset(self, index, value);
        end,
        __metatable = {2, "what?"};
    }
    local obj = setmetatable(testTable, mt);

    checkFunction({"getrawmetatable", "debug.getrawmetatable"}, {obj}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "table", "Expected 'table', got "..type(returned))

        assert(returned == mt, "returned invalid metatable")

        assert(type(returned.__index) == "function", "__index metamethod missing")
        assert(type(returned.__newindex) == "function", "__newindex metamethod missing")

        assert(type(returned.__metatable) == "table", "__metatable protection missing")
        assert(returned.__metatable[1] == 2, "__metatable value mismatch")
        assert(returned.__metatable[2] == "what?", "__metatable value mismatch")
        return 0
    end)

    local newMT = {
        __index = function(self, index)
            return "Nice!";
        end,
        __metatable = {2, "what?"}
    };
    checkFunction({"setrawmetatable", "debug.setrawmetatable"}, {testTable, newMT}, function(self)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        assert(testTable[1] == "Hello!" and testTable["what"] == 1, "returned table with invalid values")
        assert(testTable["notreal"] == "Nice!", "invalid metamethods were set")

        local new = getmetatable(testTable);
        assert(new[1] == 2 and new[2] == "what?", "__metamethod is invalid")

        return 0
    end)

    checkFunction({"setreadonly"}, {testTable, true}, function(self)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        local a, b = pcall(function()testTable[1] = "test"end);
        assert(not a, "trying to modify a readonly table doesn't return a error")
        assert(testTable[1] ~= "test", "index was set when readonly was enabled")

        setreadonly(testTable, false);
        local a, b = pcall(function()testTable[1] = "test2"end);
        assert(a, "trying to modify a table after setting readonly to false return a error")
        assert(testTable[1] == "test2", "index failed to set when readonly was disabled")
        return 0
    end)

    local testwriteable = table.freeze({})
    checkFunction({"makewriteable"}, {testwriteable}, function(self)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        local a, b = pcall(function()testwriteable[1] = "test2"end);
        assert(a, "trying to modify a table after setting readonly to false return a error")
        assert(testwriteable[1] == "test2", "index failed to set after made writeable")
        return 0
    end)

    checkFunction({"makereadonly"}, {testwriteable}, function(self)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        local a, b = pcall(function()testwriteable[1] = "makereadonlytest"end);
        assert(not a, "trying to modify a readonly table doesn't return a error")
        assert(testTable[1] ~= "makereadonlytest", "index was set when readonly was enabled")
        return 0
    end)

    checkFunction({"isreadonly"}, {testwriteable}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned) == "boolean", "Expected 'table', got "..type(returned))

        local testFunction = setreadonly or makewriteable;
        assert(testFunction, "failed to test function, missing (setreadonly or makewriteable)")

        if testFunction then
            testFunction(testwriteable, false)
            assert(not isreadonly(testwriteable), "returned true when setting readonly to false")

            testFunction(testwriteable, true)
            assert(isreadonly(testwriteable), "returned false when setting readonly to true")
        end

        return 0
    end)

    testTable = nil;
    mt = nil;
    obj = nil;
    newMT = nil;
    testwriteable = nil;
end

print("")
print("|-- WebSocket --|")
do
    checkFunction({"WebSocket.new"}, {"ws://localhost:5603/MNCtest"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata" or type(returned)=="table", "Expected 'userdata' or 'table', got "..type(returned))

        assert(returned.connected ~= nil, "returned websocket doesn't have 'connected' property")

        assert(type(returned.Connect) == "function", "returned websocket doesn't have 'Disconnect' method")
        assert(type(returned.Disconnect) == "function", "returned websocket doesn't have 'Disconnect' method")
        assert(type(returned.Send) == "function", "returned websocket doesn't have 'Disconnect' method")

        assert(typeof(returned.OnMessage) == "RBXScriptSignal", "returned websocket doesn't have 'OnMessage' signal")
        assert(typeof(returned.ConnectionClosed) == "RBXScriptSignal", "returned websocket doesn't have 'OnMessage' signal")

        returned:Disconnect()
        return 0
    end)
end

print("")
print("|-- Drawing --|")
do
    checkFunction({"Drawing.new"}, {"Square"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        assert(returned.Visible ~= nil, "returned drawing doesn't have 'Visible' property")
        assert(returned.Transparency ~= nil, "returned drawing doesn't have 'Transparency' property")
        assert(returned.Color ~= nil, "returned drawing doesn't have 'Color' property")
        assert(returned.ZIndex ~= nil, "returned drawing doesn't have 'ZIndex' property")

        assert(type(returned.Remove) == "function", "returned websocket doesn't have 'Disconnect' method")
        assert(type(returned.Destroy) == "function", "returned websocket doesn't have 'Disconnect' method")

        returned:Destroy();
        return 0
    end)
end

print("")
print("|-- Console --|")
do
    checkFunction({"rconsolecreate"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        return 1
    end, true)

    checkFunction({"rconsoletopmost"}, {true}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        return 1
    end, true)

    checkFunction({"rconsoleprint"}, {"test"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        return 1
    end, true)

    checkFunction({"rconsoleinfo"}, {"test"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        return 1
    end, true)

    checkFunction({"rconsolewarn"}, {"test"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        return 1
    end, true)

    checkFunction({"rconsoleerr"}, {"test"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        return 1
    end, true)

    checkFunction({"rconsoleclear"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        return 1
    end, true)

    checkFunction({"rconsolename"}, {"test"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        return 1
    end, true)

    checkFunction({"rconsoleinput"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        return 1
    end, true)

    checkFunction({"rconsolehide", "rconsoledestroy"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        return 1
    end, true)

    checkFunction({"rconsoleshow"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        return 1
    end, true)

    checkFunction({"rconsoletoggle"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        return 1
    end, true)

    checkFunction({"rconsolehidden"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="boolean", "Expected 'boolean', got "..type(returned))

        return 1
    end, true)

    checkFunction({"cleardevconsole"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        assert(#game:GetService("CoreGui").DevConsoleMaster.DevConsoleWindow.DevConsoleUI.MainView.ClientLog:GetChildren() == 2, "Failed to clear Dev console")

        return 0
    end)
end

print("")
print("|-- HTTP --|")
do
    local testRequest = {
        Url = "https://httpbin.org/anything",
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = HttpService:JSONEncode({ message = "Hello, world!" }),
    }
    checkFunction({"request"}, {testRequest}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="table", "Expected 'table', got "..type(returned))

        local responseBody = HttpService:JSONDecode(returned.Body)
        local responseHeaders = responseBody['headers'];

        assert(responseBody['method'] == "POST", "returned invalid method")
        assert(HttpService:JSONDecode(responseBody['data'])["message"] == "Hello, world!", "returned invalid response data")

        assert(responseHeaders["Content-Length"] == "27", "returned invalid content length")
        assert(responseHeaders["Roblox-Place-Id"] == tostring(game.PlaceId), "returned invalid PlaceId")
        assert(responseHeaders["Host"] == "httpbin.org", "returned invalid host")
        assert(responseHeaders["Content-Type"] == "application/json")

        assert(responseHeaders["Exploitidentifier"] == identifyexecutor(), "returned invalid exploitidentifier")

        return 0
    end)
    testRequest = nil;
end

print("")
print("|-- Regex --|")
do
    checkFunction({"regex.match"}, {"([A-Z])\\w+", "MNC regex Pattern"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned == "MNC", "matched to an unexpected value")
        assert(regex.match("([A-Z])\\w+", "mnc regex pattern") == "", "matched to an unexpected value")
        assert(regex.match("([A-Z])\\w+", "MNCRegexPattern") == "MNCRegexPattern", "matched to an unexpected value")

        return 0
    end)

    checkFunction({"regex.matchall"}, {"([A-Z])\\w+", "MNC regex Pattern"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="table", "Expected 'table', got "..type(returned))

        assert(returned[1] == "MNC", "match 1 matched to an unexpected value")
        assert(returned[2] ~= "regex", "match 2 matched to an unexpected value")
        assert(returned[2] == "p", "match 3 matched to an unexpected value")
        return 0
    end)

    checkFunction({"regex.replace"}, {"([A-Z])\\w+", "Replace", "MNC regex pattern"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned=="Replace regex pattern", "returned unexpected string")
        return 0
    end)
end

print("")
print("|-- Stopwatch --|")
do
    checkFunction({"stopwatch.new"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(type(returned.Start) == "function", "stopwatch is missing 'Start' method")
        assert(type(returned.Stop) == "function", "stopwatch is missing 'Start' method")
        assert(type(returned.Reset) == "function", "stopwatch is missing 'Start' method")

        return 0
    end)
end

print("")
print("|-- Parallel --|")
do
    local actor = Instance.new("Actor", ReplicatedFirst);
    checkFunction({"getactors"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="table", "Expected 'table', got "..type(returned))

        assert(returned[1] and typeof(returned[1])=="Instance", "returned actor without 'name' property")
        assert(returned[1] and returned[1].Name, "returned actor without name property")

        return 0
    end)

    checkFunction({"getactorstates"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="table", "Expected 'table', got "..type(returned))

        assert(returned[1]['Id'] and type(returned[1]['Id'])=="number", "failed to get 'Id' property")
        assert(returned[1]['IsActorState'] and type(returned[1]['IsActorState'])=="boolean", "failed to get 'IsActorState' property")

        assert(returned[1].GetActors and type(returned[1].GetActors)=="function", "failed to get 'GetActors' method")
        assert(returned[1].Execute and type(returned[1].Execute)=="function", "failed to get 'Execute' method")

        return 0
    end)

    checkFunction({"getluastate"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        assert(returned['Id'] and type(returned['Id'])=="number", "failed to get 'Id' property")
        assert(returned['IsActorState'] and type(returned['IsActorState'])=="boolean", "failed to get 'IsActorState' property")

        assert(returned.GetActors and type(returned.GetActors)=="function", "failed to get 'GetActors' method")
        assert(returned.Execute and type(returned.Execute)=="function", "failed to get 'Execute' method")

        return 0
    end)

    checkFunction({"getgamestate"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="userdata", "Expected 'userdata', got "..type(returned))

        assert(returned['Id'] and type(returned['Id'])=="number", "failed to get 'Id' property")
        assert(returned['IsActorState'] and type(returned['IsActorState'])=="boolean", "failed to get 'IsActorState' property")

        assert(returned.GetActors and type(returned.GetActors)=="function", "failed to get 'GetActors' method")
        assert(returned.Execute and type(returned.Execute)=="function", "failed to get 'Execute' method")

        return 0
    end)

    checkFunction({"checkparallel", "isparallel"}, {}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="boolean", "Expected 'boolean', got "..type(returned))

        assert(not returned, "returned true when not running in parallel")

        return 0
    end)

    local check = false;
    checkFunction({"run_on_actor"}, {actor, "return(function(check) check = true return check end)(...)", check}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="boolean", "Expected 'boolean', got "..type(returned))

        assert(returned and check, "returned true when code was not ran")
        return 0
    end)
    check = nil;
    actor:Destroy();
end

print("")
print("|-- base64 --|")
do
    checkFunction({"base64.encode", "crypt.base64.encode"}, {"MNC TEST SCRIPT"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned=="TU5DIFRFU1QgU0NSSVBU", "returned unexpected encoded string")

        return 0
    end)

    checkFunction({"base64.decode", "crypt.base64.decode"}, {"TU5DIFRFU1QgU0NSSVBU"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned=="MNC TEST SCRIPT", "returned unexpected decoded string")

        return 0
    end)
end

print("")
print("|-- url --|")
do
    checkFunction({"url.encode", "crypt.url.encode"}, {"MNC TEST SCRIPT"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned=="%4D%4E%43%20%54%45%53%54%20%53%43%52%49%50%54", "returned unexpected encoded string")

        return 0
    end)

    checkFunction({"url.decode", "crypt.url.decode"}, {"%4D%4E%43%20%54%45%53%54%20%53%43%52%49%50%54"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned=="MNC TEST SCRIPT", "returned unexpected decoded string")

        return 0
    end)
end

print("")
print("|-- hex --|")
do
    checkFunction({"hex.encode", "crypt.hex.encode"}, {"MNC TEST SCRIPT"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned=="4d4e43205445535420534352495054", "returned unexpected encoded string")

        return 0
    end)

    checkFunction({"hex.decode", "crypt.hex.decode"}, {"4d4e43205445535420534352495054"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned=="MNC TEST SCRIPT", "returned unexpected decoded string")

        return 0
    end)
end

print("")
print("|-- lz4 --|")
do

    local lz4result = "\240\0\77\78\67\32\84\69\83\84\32\83\67\82\73\80\84"
    checkFunction({"lz4.compress", "crypt.lz4.compress"}, {"MNC TEST SCRIPT"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned==lz4result, "returned unexpected compressed string")

        return 0
    end)

    checkFunction({"lz4.decompress", "crypt.lz4.decompress"}, {lz4result}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned=="MNC TEST SCRIPT", "returned unexpected decompressed string")

        return 0
    end)

    lz4result = nil
    decompressed = nil
    current = nil
end

print("")
print("|-- crypt --|")
do
    checkFunction({"crypt.hash"}, {"MNC TEST SCRIPT"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned=="8449104c3bc3a19d101f6eab75c3d7df", "cipher should defult to md5")
        assert(crypt.hash("md5", "MNC TEST SCRIPT")=="8449104c3bc3a19d101f6eab75c3d7df", "cipher should defult to md5")
        assert(crypt.hash("sha1", "MNC TEST SCRIPT")=="30fcc77b84855f4eef878322bdbad979c81cf4fc", "returned unexpected sha1 hashed string")
        assert(crypt.hash("sha256", "MNC TEST SCRIPT")=="bc5255b73a53bca46f3b8316a9d6d5423b65e4c9357b9a4ed16093220a8a6659", "returned unexpected sha256 hashed string")

        return 0
    end)

    checkFunction({"crypt.hmac"}, {"MNC TEST SCRIPT", "key1"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned=="3ac30d2ec6cd431d9b3aa6b4fbe68d6c", "cipher should defult to md5")
        assert(crypt.hmac("md5", "MNC TEST SCRIPT", "key1")=="3ac30d2ec6cd431d9b3aa6b4fbe68d6c", "returned unexpected hmac sha1 hashed string")
        assert(crypt.hmac("sha1", "MNC TEST SCRIPT", "key1")=="b0889d98d89736421b60cb18bd630e6bcf2b4c0f", "returned unexpected hmac sha1 hashed string")
        assert(crypt.hmac("sha256", "MNC TEST SCRIPT", "key1")=="f0af3f08fd591bf5282df9664a2a0f899b010f0c9b18a9f92d0826039d4afef2", "returned unexpected hmac sha256 hashed string")

        return 0
    end)
end

print("")
print("|-- debug --|")
do
    local a,b,c,d;
    local function testFunction()
        a, b = true, false;
        local aa = "test1".."test2"
        c = function()
            return "function"
        end
        d = function()
            return 1
        end
        return c()
    end
    testFunction()

    checkFunction({"debug.isvalidlevel"}, {1}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="boolean", "Expected 'boolean', got "..type(returned))

        assert(returned, "returned false on a valid level")
        assert(not debug.isvalidlevel(6), "returned true on a invalid level")

        return 0
    end)

    checkFunction({"debug.getprotos"}, {testFunction}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="table", "Expected 'table', got "..type(returned))

        assert(debug.info(returned[1], "slna") == debug.info(c, "slna"), "returned invalid protos")
        assert(debug.info(returned[2], "slna") == debug.info(d, "slna"), "returned invalid protos")

        return 0
    end)

    checkFunction({"debug.getproto"}, {testFunction, 1, true}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="table", "Expected 'table', got "..type(returned))

        assert(returned[1]() ~= a, "returned unexpected proto value")
        assert(returned[2]() ~= b, "returned unexpected proto value")

        assert(type(debug.getproto(testFunction, 1, true)[1]()) ~= "function", "returned invalid proto")

        return 0
    end);

    checkFunction({"debug.getstack"}, {3}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="table", "Expected 'table', got "..type(returned))

        assert(debug.getstack(3, 1)[1] == "debug.getstack", "returned invalid method")
        assert(returned[1] == game:GetService("HttpService"), "returned invalid method")
        assert(returned[2] == Players, "returned invalid method")
        assert(returned[3] == game:GetService("ReplicatedFirst"), "returned invalid method")

        return 0
    end)

    checkFunction({"debug.setstack"}, {3, 1, Players}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        assert(debug.getstack(4, 1) == Players, "failed to set stack")
        debug.setstack(4, 1, game:GetService("HttpService"))

        return 0
    end)

    checkFunction({"debug.getupvalues"}, {testFunction}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="table", "Expected 'table', got "..type(returned))

        assert(returned[1] == a, "returned invalid upvalues")
        assert(returned[2] == b, "returned invalid upvalues")
        assert(returned[3] == c and returned[3]() == c(), "returned invalid upvalues")
        assert(returned[4] == d and returned[4]() == d(), "returned invalid upvalues")

        return 0
    end)

    checkFunction({"debug.getupvalue"}, {testFunction, 1}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="boolean", "Expected 'boolean', got "..type(returned))

        assert(returned == a, "returned invalid upvalue")
        assert(debug.getupvalue(testFunction, 2) == b, "returned invalid upvalue")
        assert(debug.getupvalue(testFunction, 3) == c and debug.getupvalue(testFunction, 3)() == c(), "returned invalid upvalue")
        assert(debug.getupvalue(testFunction, 4) == d and debug.getupvalue(testFunction, 4)() == d(), "returned invalid upvalue")

        return 0
    end)

    checkFunction({"debug.setupvalue"}, {testFunction, 1, false}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        assert(debug.getupvalue(testFunction, 1) == false, "returned invalid upvalue")
        debug.setupvalue(testFunction, 1, true)

        return 0
    end)

    checkFunction({"debug.getconstants"}, {testFunction}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="table", "Expected 'table', got "..type(returned))

        assert(returned[1] == "test1", "returned invalid constants")
        assert(returned[2] == "test2", "returned invalid constants")

        return 0
    end)

    checkFunction({"debug.getconstant"}, {testFunction, 1}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")
        assert(type(returned)=="string", "Expected 'string', got "..type(returned))

        assert(returned == "test1", "returned invalid constants")
        assert(debug.getconstant(testFunction, 2) == "test2", "returned invalid constants")

        return 0
    end)

    checkFunction({"debug.setconstant"}, {testFunction, 1, "nottest1"}, function(self, returned)
        assert(debug.info(self, "s") == "[C]", "Function is not native C")

        assert(debug.getconstant(testFunction, 1) == "nottest1", "failed to set constant")
        debug.setconstant(testFunction, 1, "test1")
        debug.setconstant(testFunction, 2, "nottest2")
        assert(debug.getconstant(testFunction, 2) == "nottest2", "failed to set constant")
        debug.setconstant(testFunction, 2, "test2")

        return 0
    end)
    a,b,c,d = nil, nil, nil, nil
end

local total = Pass + NA + Fail
local passPercent = string.format("%.2f%%", (Pass / total) * 100)
local naPercent = string.format("%.2f%%", (NA / total) * 100)
local failPercent = string.format("%.2f%%", (Fail / total) * 100)

print("")
print("|-------------------------|")
print("| Mp3's Naming Convention |")
print("| 游릴 - Pass |", Pass, "|", passPercent, "|")
print("| 游릱 - N/A  |", NA, "|", naPercent, "|")
print("| 游린 - Fail |", Fail, "|", failPercent, "|")
print("| Executor: ".. (identifyexecutor and identifyexecutor() or "Unknown") .." |")
print("|-------------------------|")
if game.PlaceId ~= 17574618959 then
    print("| 丘멆잺 You're not in 'a literal baseplate.', You might encounter some errors. 丘멆잺 |")
    print("|-------------------------|")
end
